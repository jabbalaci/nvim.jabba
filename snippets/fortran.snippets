snippet imp
	implicit none
snippet impl
	implicit none
snippet prog
	program ${1:main}
	   implicit none
	   $0
	end program $1
snippet iface
	interface ${1:name}
	   !# add "implicit none" to its subprograms
	   ${0}
	end interface $1
snippet doc
	! """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	! File: ${2:`vim_snippets#Filename('$1')`}
	! Author: `g:snips_author`
	! Email: `g:snips_email`
	! Github: `g:snips_github`
	! Description: $1
	! """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	$0
# Variables definitions
# Boolean
snippet bool
	logical
# Integer
snippet int
	integer
# Double Precision
# snippet double
# double precision :: $0
# Char
snippet char
	character
snippet str
	character(len=${1:10}) :: ${2:name}
snippet str_const
	character(len=*), parameter :: ${1:name} = "${2:value}"
snippet const
	${1:type}, parameter :: ${2:name} = ${3:value}
snippet MAX
	integer, parameter :: ${1:NAME} = ${2:value}
snippet TAB
	character(len=1), parameter :: TAB = achar(9)
	character(len=2), parameter :: TAB2 = achar(9)//achar(9)
	character(len=3), parameter :: TAB3 = achar(9)//achar(9)//achar(9)
snippet intent
	${1:type}, intent(in) :: $0
# Array
snippet /
	(/ $1 /) ${2:,&} $0
snippet if
	if (${1:condition}) then
	   $2
	end if
snippet elseif
	else if ($0) then
snippet then
	then
	   $0
	end if
snippet select
	select case (${1:expr})
	   case (${2:value})
	      !# ...
	   case default
	      !# ...
	end select
snippet do
	do ${1:i} = ${2:start},${3:end}
	   $4
	end do
snippet dow
	do while (${1:condition})
	   $2
	end do
snippet read
	read(unit = ${1:fp}, file = ${2:filename}${3:, iostat = IERR }) $0
snippet write
	write(unit = ${1:fp}, file = ${2:filename}${3:, iostat = IERR }) $0
snippet open
	open(unit = ${1:fp}, file = ${2:filename}, status = unknown${3:, iostat = IERR }) $0
snippet close
	close(unit = ${1:fp}) $0
###############################
### My (Laszlo's) own stuff ###
###############################
snippet alap
	program alap
	   implicit none
	   print '(a)', "$0Fortran"
	end program alap
snippet pr
	print *, $0
snippet wr
	write (*,*) $0
snippet wr_stderr
	write (stderr, '(*(g0))') "Error: ..."
snippet pr_joker
	print '(*(g0))', $0
snippet pr_space
	print '(*(g0,x))', $0
snippet joker
	'(*(g0))'
snippet space
	'(*(g0,x))'
snippet text
	'(a)'
snippet i0
	'(i0)'
snippet pr_str
	print '(a)', "$0"
snippet pr_int
	print '(i0)', $0
snippet blank
	print *
snippet buffer
	character(len=256) :: buffer
snippet str_dyn
	character(len=:), allocatable :: name
snippet input
	write (*, '(a)', advance="no") "Name: "
	read (*, '(a)') buffer  !# read the whole line, don't stop at the first space
	!# read (*, '(a)') char  !# use this when reading a character
	!# read (*, *) age  !# where age is an integer, for instance
	!# best way: read as text and convert it to whatever you need (and check iostat)
snippet char
	character
snippet halt
	stop  !# die
snippet die
	stop  !# die
snippet break
	exit  !# break
snippet continue
	cycle  !# continue
snippet loop
	do
	   $0
	end do
snippet off
	!&<
snippet on
	!&>
snippet true
	.true.
snippet false
	.false.
snippet openFileForRead
	integer :: unit, ios
	open(newunit=unit, file="input.txt", status="old", action="read", iostat=ios)
	if (ios /= 0) then
       print *, "Error: cannot open file"
       stop 1
   	end if
snippet readLineFromFile
	character(len=100) :: line
	do
	   read(unit, '(a)', iostat=ios) line
       if (ios /= 0) then
          exit  !# break
       end if
	   !# ...
	end do
snippet pi
	use iso_fortran_env, only: sp => real32, dp => real64
	real(dp), parameter :: PI = acos(-1.0_dp)
snippet float
	use iso_fortran_env, only: sp => real32, dp => real64
	real(sp) :: szimpla = 0.1_sp  !# Always use a kind suffix for floating-point literal constants.
snippet double
	use iso_fortran_env, only: sp => real32, dp => real64
   	real(dp) :: dupla = 0.2_dp  !# Always use a kind suffix for floating-point literal constants.
snippet block
	block
	   $0
	end block
snippet dim
	dimension($0)
snippet arr
	integer, dimension(10) :: numbers
snippet arrd
	${1:type}, allocatable, dimension(${2::}) :: $0
snippet hl
	print '(a)', "---"
snippet printMatrix
	do i = 1, size(matrix, 1)  !# iterate over the rows
       print *, matrix(i, :)
	end do
snippet assoc
	associate ($0my_alias => ...)

   	end associate
snippet alloc
	allocate($0)
snippet dealloc
	deallocate($0)
snippet and
	.and. 
snippet or
	.or. 
snippet not
	.not. 
snippet eq
	.eqv. 
snippet neq
	.neqv. 
snippet cont
	contains
snippet proc
	procedure
snippet self
	class(${1:t_type}), intent(in) :: self
snippet instance
	type(t_square) :: negyzet
snippet sub
	subroutine ${1:name}(${2:arg1})
	   ${3:type1}, intent(in) :: ${4:arg1}

	end subroutine
snippet func
	function ${1:name}(${2:arg1}) result(result)
	   ${3:type1}, intent(in) :: ${4:arg1}
	   ${5:type2} :: result

	end function
snippet mod
	module ${1:my_mod}
	   implicit none
	   private

	   public :: public_var, public_subprogram

	contains

	end module $1
snippet int_i
	integer :: i
snippet ii
	integer :: i
snippet str_param
	character(len=*), intent(in) :: s
snippet optional_parameter
	!# call greet("L치szl칩")
	!# call greet("L치szl칩", greetings="Bonjour")
	subroutine greet(name, greetings)
	   character(len=*), intent(in) :: name
	   character(len=*), intent(in), optional :: greetings
	   character(:), allocatable :: greetings_value
	   if (present(greetings)) then
	      greetings_value = greetings
	   else
	      greetings_value = "Hello"
	   end if

	   print '(4a)', greetings_value, ", ", name, "!"
	end subroutine
snippet type
	type :: t_${1:name}
	   $0
	end type
	!# type(t_pair) :: pair
snippet res
	result
snippet to_int
	read (s, *) n  !# str2int; s -> n; read from s and put the result in n; s must be a variable (not a constant)
snippet to_str
	write (s, '(i0)') n  !# int2str; s <- n; write the value of n into s
snippet ord_chr
	!# chr(65) -> 'A'; achar(65) -> 'A'
	!# ord('A') -> 65; iachar('A') -> 65
snippet inner
	intrinsic
snippet tab_lf
	use stdlib_ascii, only: tab, lf
snippet argc_argv
	!# argc:    command_argument_count()  , int
	!# argv[i]: use jsys; s = argv(i)     , file's name at index position 0
snippet stdin_stdout_stderr
   use iso_fortran_env, only: stdin => input_unit, &    !# 5
                              stdout => output_unit, &  !# 6
                              stderr => error_unit      !# 0
snippet stdin
   use iso_fortran_env, only: stdin => input_unit
snippet stdout
   use iso_fortran_env, only: stdout => output_unit
snippet stderr
   use iso_fortran_env, only: stderr => error_unit
